using System.Collections;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Pmad.PreBuiltMEF.SourceGeneration.Model;

namespace Pmad.PreBuiltMEF.SourceGeneration
{
    [Generator(LanguageNames.CSharp)]
    public class PreBuiltMEFSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Étape 1 : Filtrer les classes avec ExportAttribute, ImportingConstructorAttribute,
            // ou une propriété avec ImportAttribute ou ExportAttribute
            var exportedClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => PartModel.IsTargeted(node),
                    transform: (ctx, _) =>
                    {
                        var classDecl = (Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)ctx.Node;
                        if (!(ctx.SemanticModel.GetDeclaredSymbol(classDecl) is INamedTypeSymbol symbol))
                            return null;
                        return PartModel.Create(symbol);
                    })
                .Where(c => c != null)
                .Collect();

            var assemblyNameProvider = context.CompilationProvider.Select((compilation, _) => compilation.AssemblyName);

            // Étape 2 : Générer le code d'appel à PreCompiledCatalogBuilder
            context.RegisterSourceOutput(assemblyNameProvider.Combine(exportedClasses), (spc, tuple) =>
            {
                var parts = tuple.Right;
                if (parts.IsDefaultOrEmpty)
                {
                    // Si aucune classe exportée, on ne génère rien
                    return;
                }

                // Récupération du nom de l'assembly en cours de compilation

                var sb = new System.Text.StringBuilder();
                sb.AppendLine("// This file is auto-generated by Pmad.PreBuiltMEF.SourceGeneration");
                sb.AppendLine("#nullable enable");
                sb.AppendLine($"using System.Linq;");
                sb.AppendLine($"using Pmad.PreBuiltMEF;");
                sb.AppendLine($"namespace {tuple.Left}");
                sb.AppendLine("{");
                sb.AppendLine("public static class _PreBuiltMEF");
                sb.AppendLine("{");
                sb.AppendLine("  public static void RegisterAllParts(Pmad.PreBuiltMEF.PreBuiltCatalogBuilder builder)");
                sb.AppendLine("  {");

                var mapper = new MetadataMapperBuilder();

                foreach (var part in parts)
                {
                    WritePart(sb, part!, mapper);
                    sb.AppendLine();
                }



                sb.AppendLine("  }");
                mapper.AppendTo(sb);

                sb.AppendLine("}");
                sb.AppendLine("}");

                spc.AddSource("_PreBuiltMEF.g.cs", sb.ToString());
            });
        }

        private static void WritePart(System.Text.StringBuilder sb, PartModel part, MetadataMapperBuilder mapper)
        {

            if (part.ImportingConstructorParameters != null)
            {
                var sbAddImports = new System.Text.StringBuilder();

                sb.Append($"    builder.AddPart<{part.Type}>(scope => new {part.Type}(");
                bool isFirst = true;
                int index = 0;
                foreach (var param in part.ImportingConstructorParameters)
                {
                    if (!isFirst)
                    {
                        sb.Append(", ");
                    }
                    else
                    {
                        isFirst = false;
                    }
                    sb.Append($"({param.ParamType})scope[{index}]");
                    var method = param.Mode < ImportMode.Many ? "AddConstructorImport" : "AddConstructorImportMany";
                    if (param.Mode == ImportMode.Lazy)
                    {
                        method += "Lazy";
                    }
                    AddImport(sbAddImports, mapper, param, method, "");
                    index++;
                }
                sb.Append("))");
                sb.Append(sbAddImports);
            }
            else
            {
                sb.Append($"    builder.AddPart<{part.Type}>()");
            }

            foreach (var metadata in part.Metadata)
            {
                sb.AppendLine();
                sb.Append($"      .AddMetadata({metadata.Key},{metadata.Value})");
            }

            foreach (var partExport in part.PartExports)
            {
                sb.AppendLine();
                sb.Append($"      .AddExport<{partExport.Type}>(");
                if (!string.IsNullOrEmpty(partExport.ContractName))
                {
                    sb.Append($"\"{partExport.ContractName}\", ");
                }
                sb.Append("part => part");
                if (partExport.Metadata != null && partExport.Metadata.Count > 0)
                {
                    sb.Append(", ");
                    MetadataHelper.AppendMetadata(sb, partExport.Metadata);
                }
                sb.Append(")");
            }

            foreach (var memberExport in part.MemberExports)
            {
                sb.AppendLine();
                sb.Append($"      .AddExport<{memberExport.Type}>(");
                if (!string.IsNullOrEmpty(memberExport.ContractName))
                {
                    sb.Append($"\"{memberExport.ContractName}\", ");
                }
                sb.Append($"part => part.{memberExport.Name}");
                if (memberExport.Metadata != null && memberExport.Metadata.Count > 0)
                {
                    sb.Append(", ");
                    MetadataHelper.AppendMetadata(sb, memberExport.Metadata);
                }
                sb.Append(")");
            }
            foreach (var memberImport in part.MemberImports)
            {
                var method = "AddImport";
                if (memberImport.Mode >= ImportMode.Many)
                {
                    method = "AddImportMany";
                }
                AddImport(sb, mapper, memberImport, method, $"(part, value) => part.{memberImport.Name} = value");
            }
            sb.AppendLine($";");
        }

        private static void AddImport(System.Text.StringBuilder sb, MetadataMapperBuilder mapper, ImportBase memberImport, string method, string body)
        {
            sb.AppendLine();
            sb.Append($"      .{method}<{memberImport.GetGenericArgs()}>(");
            var needComma = false;
            if (!string.IsNullOrEmpty(memberImport.ContractName))
            {
                sb.Append($"\"{memberImport.ContractName}\"");
                needComma = true;
            }
            if (!string.IsNullOrEmpty(body))
            {
                if (needComma)
                {
                    sb.Append(", ");
                }
                sb.Append(body);
                needComma = true;
            }
            if (memberImport.Metadata != null)
            {
                if (needComma)
                {
                    sb.Append(", ");
                }
                var impl = mapper.GetOrCreate(memberImport.Metadata);
                sb.Append($"{impl}.Create, {impl}.IsValid");
                needComma = true;
            }
            if (memberImport.AllowDefault)
            {
                if (needComma)
                {
                    sb.Append(", ");
                }
                sb.Append($"allowDefault: true");
                needComma = true;
            }
            sb.Append(")");
        }

        private static string Boolean(bool allowDefault)
        {
            return allowDefault ? "true" : "false";
        }
    }
}
